"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiBookmarks = void 0;
const abstract_1 = require("./abstract");
const apiRoute_1 = require("../http/apiRoute");
const itemType_1 = require("../interfaces/itemType");
const apiError_1 = require("../http/apiError");
class ApiBookmarks extends abstract_1.ApiAbstract {
    constructor() {
        super(...arguments);
        this.cache = new Map(); //false - если данные не получены с сервера по ключу 
        this.timeout = undefined;
        this.requestKeys = new Set();
        this.total = null;
    }
    /**
     * принимает id акции (не товара) который находится в поле id метода возвращаемых товаров getCatalogList. В методе есть дебаунсер, что позволяет его вызвать для каждого товара на странице сделав только 1 запрос на сервер
     * @param {number} props.sku - id акции (не товара)
     */
    async inBookmarks({ skuId }) {
        if (!skuId || skuId <= 0)
            return false;
        if (!await this.userStorage.isAuth())
            return false;
        const key = `${itemType_1.ItemType.CATALOG_SKU}-${skuId}`;
        return await this.collectKeys(key);
    }
    async collectKeys(key) {
        //has cache
        if (this.cache.has(key)) {
            const val = this.cache.get(key);
            if (val !== false)
                return true;
            return false;
        }
        //no cache
        //собираем включи для 1 запроса со всех вызовов
        if (!this.requestKeys.has(key)) {
            if (this.timeout)
                clearTimeout(this.timeout);
            this.requestKeys.add(key);
            this.timeout = setTimeout(async () => {
                if (!this.requestKeys.size)
                    return;
                //все компоненты отрендерены, ключи все запрошены, можно выполнять запрос
                try {
                    const arrFromRequestKeys = Array.from(this.requestKeys);
                    const data = await this.fetcher({
                        route: apiRoute_1.apiRouteBookmarksGet,
                        postBody: { itemKeys: arrFromRequestKeys },
                        options: { addToken: true }
                    });
                    for (const requestKey of arrFromRequestKeys) {
                        const find = data.find(it => it.item_key == requestKey);
                        this.cache.set(requestKey, find?.item_key || false);
                    }
                }
                catch (error) {
                    this.cache.set(key, false);
                    console.error(error);
                }
                this.requestKeys.clear(); //очистка очереди запросов
            }, 200);
        }
        //ждем последнего запроса
        await new Promise(r => setTimeout(r, 300)); //sleep
        return await this.collectKeys(key); //на следующем крузе вернется результат из кэша
    }
    /**
     * добавление \ удаление из избранного
     * @param {number} props.sku - id акции (не товара)
     * @param {UserStatEvent} props.isAdd - признак добавление или удаление
     */
    async mutate({ skuId, isAdd }) {
        if (!skuId || skuId <= 0)
            return;
        if (!await this.userStorage.isAuth())
            throw new apiError_1.ApiError(401, "Пользователь не авторизован");
        try {
            await this.fetcher({
                route: isAdd
                    ? apiRoute_1.apiRouteBookmarksAdd
                    : apiRoute_1.apiRouteBookmarksRemove,
                postBody: {
                    itemType: itemType_1.ItemType.CATALOG_SKU,
                    itemId: skuId
                },
                options: {
                    addToken: true
                }
            });
        }
        catch (error) {
            console.error(error);
        }
        const key = `${itemType_1.ItemType.CATALOG_SKU}-${skuId}`;
        this.cache.set(key, isAdd ? key : false);
        this.total = (this.total ?? 0) + (isAdd ? 1 : -1);
    }
    /**
     * возвращает кол-во товаров в избранном или null в случае ошибки
     */
    async getTotal() {
        if (this.total !== null)
            return this.total;
        if (!await this.userStorage.isAuth())
            return null;
        try {
            const total = await this.fetcher({
                route: apiRoute_1.apiRouteBookmarksCount,
                options: { addToken: true }
            });
            this.total = total;
        }
        catch (error) {
            console.error(error);
        }
        return this.total;
    }
}
exports.ApiBookmarks = ApiBookmarks;
