"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiChat = void 0;
const abstract_1 = require("./abstract");
const webSocketClient_1 = require("../service/webSocketClient");
const apiError_1 = require("../http/apiError");
const userLogout_1 = require("../eventBus/userLogout");
//import { eventBusUserLogin } from "../eventBus/userLogin"
class ApiChat extends abstract_1.ApiAbstract {
    constructor({ host, wsHost, userStorage }) {
        super({ host, userStorage });
        this.messageHistory = [];
        this.messageSubscriptions = new Set();
        this.client = new webSocketClient_1.WebSocketClient(wsHost);
        this.client.onOpen(async () => await this.auth());
        this.client.onMessage(message => {
            //prepare
            const data = JSON.parse(message);
            if (!Array.isArray(data)) {
                console.error('Входящее сообщения должны быть массивом', data);
                return;
            }
            for (const item of data) {
                if ("date" in item)
                    item.date = new Date(item.date);
            }
            //broadcast
            for (const callback of Array.from(this.messageSubscriptions)) {
                callback(data);
            }
            //Последние 10 групп сообщений с сервера для новых подписчиков
            this.messageHistory.push(data);
            if (this.messageHistory.length > 10) {
                this.messageHistory.splice(0, this.messageHistory.length - 10);
            }
        });
        // eventBusUserLogin.subscribe(async () => this.client.connect())
        // this.userStorage.isAuth().then(isAuth => {
        //     if (isAuth) this.client.connect()
        // })
        userLogout_1.eventBusUserLogout.subscribe(async () => this.client.close());
    }
    async auth() {
        const token = await this.getToken();
        if (!token) {
            console.error("User token for WebSocket empty");
            return;
        }
        this.client.send(JSON.stringify({ token }), true);
    }
    messageSubscribe(callback) {
        this.messageSubscriptions.add(callback);
        //Последние 10 групп сообщений с сервера для новых подписчиков
        for (const history of this.messageHistory)
            callback(history);
        return () => { this.messageSubscriptions.delete(callback); };
    }
    async sendMessage({ text, file }) {
        const user = await this.userStorage?.getUser();
        if (!user)
            throw new apiError_1.ApiError(401, "Пользователь не авторизован");
        if (user.role !== 0)
            throw new apiError_1.ApiError(400, "Для тестирования чата авторизуйтесь под обычного пользователя");
        const convertToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        };
        const firstFile = file instanceof FileList
            ? Array.from(file)?.pop()
            : file;
        const message = {
            route: "/message",
            text,
            file: firstFile ? await convertToBase64(firstFile) : undefined
        };
        this.client.send(JSON.stringify(message));
    }
    sendView({ id }) {
        const message = {
            route: "/view",
            message_id: id
        };
        this.client.send(JSON.stringify(message));
    }
    // getDialogs({page}:{page: number}) {//оставим для оптимизации если диалогов будет много
    //     this.client.send(JSON.stringify({
    //         route: "/get/dialogs",
    //         page,
    //     }))
    // }
    getMessages({ page }) {
        this.client.send(JSON.stringify({
            route: "/get/messages",
            page,
        }));
    }
}
exports.ApiChat = ApiChat;
