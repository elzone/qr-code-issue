"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiContent = void 0;
const apiRoute_1 = require("../http/apiRoute");
const abstract_1 = require("./abstract");
class ApiContent extends abstract_1.ApiAbstract {
    /**
     * получение настроек, включая размер реферальных вознаграждений
     */
    async getEnv() {
        return this.fetcher({ route: apiRoute_1.apiRouteEnv });
    }
    /**
     * получение дерева категорий. не обязательный параметр
     * @param {string} parent id категории от которой строится вложенность
     */
    async getNodeTree(parent) {
        return this.fetcher({ route: (0, apiRoute_1.apiRouteNodeTree)(parent) });
    }
    /**
     * получение списка категорий по фильтрам
     */
    // private async getNodeList<T>(params: iGetNodeListProps<T>) {
    //     return this.fetcher<iNode<T>[]>({
    //         route: apiRouteNodeList(params)
    //     })
    // }
    /**
     * получение раздела
     */
    async getNodeByCode(nodeCode) {
        return this.fetcher({
            route: (0, apiRoute_1.apiRouteNode)(nodeCode)
        });
    }
    /**
     * получение списка категорий по фильтрам
     */
    // async getNodeListCatalog(params: iGetNodeListProps<iCatalogNode>) {
    //     return this.getNodeList(params)
    // }
    /**
    * получение списка статей
    */
    async getArticleList({ select, page = 1, //отсчет страниц с первой, чтобы не было путаницы
    filters, sorters, perPage = 10, }) {
        return this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "articles",
                page,
                select,
                filters,
                sorters,
                perPage,
            })
        });
    }
    /**
    * получение одной статьи
    */
    async getArticleOne({ id }) {
        return this.fetcher({
            route: (0, apiRoute_1.apiRouteItemById)("articles", id)
        });
    }
    /**
    * получение списка акций
    * @param {number} params.nodeId - id раздела, если не передан будут выбраны товары всех разделов
    * @param {boolean} params.subNodes - включить или нет товары подкатегорий
    * @param {boolean} params.bookmarks - показать только избранные товары
    */
    async getCatalogList({ nodeId, page = 1, //отсчет страниц с первой, чтобы не было путаницы
    filters, 
    // sorters,
    perPage = 10, subNodes, bookmarks, }) {
        const data = await this.fetcher({
            route: (0, apiRoute_1.apiRouteCatalogList)({
                nodeId: nodeId ?? 0,
                page,
                filters,
                //sorters,
                perPage,
                subNodes,
                bookmarks,
            }),
            options: {
                addToken: true
            }
        });
        return data;
    }
    /**
   * получение одного товара (акции)
   *  @param {string} id - id акции
   */
    async getCatalogOne({ id }) {
        const data = await this.fetcher({ route: (0, apiRoute_1.apiRouteCatalogItem)(id) });
        return data;
    }
    /**
     * проверка действует ли акция в аптеке пользователя
     * @param {string} id - id акции
     */
    async skuInUserShop({ id }) {
        const data = await this.fetcher({
            route: (0, apiRoute_1.apiRouteCatalogInUserShop)(id),
            options: { addToken: true }
        });
        return data.contains;
    }
    /**
     * проверка по ИНН аптеки участвует или нет акция в аптеке
     * @param {string} params.id - id акции
     * @param {string} params.inn - ИНН аптеки
     */
    async inShopByInn({ id, inn }) {
        const data = await this.fetcher({
            route: (0, apiRoute_1.apiRouteCatalogInShopByInn)(id, inn),
        });
        return data.contains;
    }
    /**
  * симптомы
  * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
  * @param {string} props.searchTitle - поисковая строка по началу названия банка
  */
    async getSymptoms({ page, searchTitle }) {
        const filters = {};
        if (searchTitle?.length)
            filters.title = [searchTitle + "%"];
        return await this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "symptoms",
                select: ["id", "title"],
                sorters: ["sorter asc"],
                perPage: 30,
                filters,
                page
            })
        });
    }
    /**
     * получение списка производителей
     */
    async getBrandList({ select, page = 1, //отсчет страниц с первой, чтобы не было путаницы
    filters, sorters, perPage = 10, }) {
        const data = await this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "brand",
                page,
                select,
                filters,
                sorters,
                perPage,
            })
        });
        return data;
    }
    /**
    * политика конфиденциальности
    */
    async getPolicy() {
        return this.getNodeByCode("policy");
    }
    /**
   * оферта
   */
    async getTerms() {
        return this.getNodeByCode("terms");
    }
    /**
   * Правила программы лояльности
   */
    async getLoyalty() {
        return this.getNodeByCode("loyalty");
    }
    /**
    * как получить деньги
    */
    async getInstruction() {
        return await this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "instruction",
                select: ["id", "title", "text", "image"],
                sorters: ["sorter asc"],
                perPage: 100,
            })
        });
    }
    /**
   * банки для выбора при запросе на вывод средств
   * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
   * @param {string} props.searchTitle - поисковая строка по началу названия банка
   */
    async getBanks({ page, searchTitle }) {
        const filters = {};
        if (searchTitle?.length)
            filters.title = [searchTitle + "%"];
        return await this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "bank",
                select: ["id", "title"],
                sorters: ["sorter asc", "title asc"],
                perPage: 10,
                filters,
                page
            })
        });
    }
    /**
   * поиск города
   * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
   * @param {string} props.searchTitle - поисковая строка по началу названия банка
   */
    async getCityList({ page, searchTitle }) {
        const filters = {};
        if (searchTitle?.length)
            filters.title = [searchTitle + "%"];
        return await this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "city",
                select: ["id", "title"],
                sorters: ["sorter asc"],
                perPage: 20,
                filters,
                page
            })
        });
    }
    /**
    * получение одного города
    */
    async getCityOne({ id }) {
        return this.fetcher({
            route: (0, apiRoute_1.apiRouteItemById)("city", id)
        });
    }
    /**
     * поиск аптеки
     * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
     * @param {string} props.searchTitle - поисковая строка по началу названия аптеки
     */
    async getShopList({ page, searchTitle }) {
        const filters = {};
        if (searchTitle?.length)
            filters.title = [searchTitle + "%"];
        return await this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "shop",
                select: ["id", "title", "inn", "address"],
                sorters: ["sorter asc"],
                perPage: 20,
                filters,
                page
            })
        });
    }
    /**
    * получение одной аптеки
    */
    async getShopOne({ id }) {
        return this.fetcher({
            route: (0, apiRoute_1.apiRouteItemById)("shop", id)
        });
    }
    /**
     * баннер
     * @param {number} props.type - тип баннера
     */
    async getBannerRand({ type }) {
        return await this.fetcher({
            route: (0, apiRoute_1.apiRouteBannerGetRand)(type),
            options: { addToken: true }
        });
    }
    /**
    * получение списка сторисов
    */
    async getStoriesList({ select, page = 1, //отсчет страниц с первой, чтобы не было путаницы
    perPage = 10, }) {
        const data = await this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "stories",
                page,
                select,
                perPage,
            }),
            options: { addToken: true }
        });
        return {
            ...data,
            items: data.items.map(it => ({
                ...it,
                sku: it?.sku
                    ? { id: it.sku.id, title: it.sku.title }
                    : null
            }))
        };
    }
    /**
    * получение одного сториса
    */
    async getStoriesOne({ id }) {
        const data = await this.fetcher({
            route: (0, apiRoute_1.apiRouteItemById)("stories", id)
        });
        return {
            ...data,
            item: {
                ...data.item,
                sku: data.item?.sku
                    ? { id: data.item.sku.id, title: data.item.sku.title }
                    : null
            }
        };
    }
    /**
   * получение списка интро (приветственная инструкция)
   */
    async getIntro() {
        return this.fetcher({
            route: (0, apiRoute_1.apiRouteList)({
                nodeCode: "intro",
                select: ["id", "title", "image"],
                sorters: ["sorter asc"],
                perPage: 50,
            })
        });
    }
}
exports.ApiContent = ApiContent;
