"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiUser = void 0;
const apiError_1 = require("../http/apiError");
const apiRoute_1 = require("../http/apiRoute");
const abstract_1 = require("./abstract");
const userLogin_1 = require("../eventBus/userLogin");
const userLogout_1 = require("../eventBus/userLogout");
class ApiUser extends abstract_1.ApiAbstract {
    constructor() {
        super(...arguments);
        /**
       * подписка на событие logout
       */
        this.onLogout = userLogout_1.eventBusUserLogout.subscribe;
    }
    /**
     * получает пользователя из расшифрованного JWT токена без запроса на backend
     */
    get() {
        return this.userStorage.getUser();
    }
    /**
     * получает полную информацию о пользователе с сервера
     */
    async getFull() {
        if (!await this.userStorage.isAuth())
            throw new apiError_1.ApiError(401, "Пользователь не авторизован");
        return this.fetcher({ route: apiRoute_1.apiRouteUserGetMe, options: { addToken: true } });
    }
    /**
    * 1ый этап регистрации или авторизации
    */
    async loginOrRegisterByPhone({ phone }) {
        try {
            await this.fetcher({ route: apiRoute_1.apiRouteUserLoginWithCode, postBody: { login: phone } });
        }
        catch (error) {
            if (error instanceof apiError_1.ApiError && error.message == "confirm_phone")
                return;
            throw error;
        }
    }
    /**
     * 2ой этап регистрации или авторизации - ввод кода подтверждения
     */
    async loginOrRegisterByPhoneConfirm({ phone, code }) {
        const data = await this.fetcher({
            route: apiRoute_1.apiRouteUserLoginWithCode,
            postBody: { login: phone, phone_code: code }
        });
        const user = await this.userStorage.setUser(data.accessToken, data.refreshToken);
        if (user)
            userLogin_1.eventBusUserLogin.broadcast(user);
        return user;
    }
    /**
    * Ввод реферального кода другого пользователя
    * @param {string} props.ref - реферальный код
    */
    async setRef({ ref }) {
        await this.fetcher({
            route: apiRoute_1.apiRouteUserSetRef,
            postBody: { ref },
            options: { addToken: true }
        });
    }
    /**
    * Установка любимой аптеки по ее ИНН
    * @param {string} props.inn - ИНН аптеки
    */
    async setShopByInn({ inn }) {
        await this.fetcher({
            route: apiRoute_1.apiRouteUserSetShopByInn,
            postBody: { inn },
            options: { addToken: true }
        });
    }
    /**
    * редактирование пользователя
    * если метод вернул false - то необходимо ввести код из email и передать его в data.email_code
    * @param {string} props.email - опционально, для смены email. Если емейл не меняется то не передаем этот параметр или передаем пустую строку
    * @param {number} props.city - id города
    * @param {string} props.email_code - код отправленный на email. Первый раз метод вызывается без него, если метод вернул false необходимо вызвать повторно передав код из email
    */
    async editUser(data) {
        if (!await this.userStorage.isAuth())
            throw new apiError_1.ApiError(401, "Пользователь не авторизован");
        try {
            await this.fetcher({
                route: apiRoute_1.apiRouteUserEdit,
                postBody: data,
                options: { addToken: true }
            });
            if (data.firstname?.length && data.lastname?.length) {
                await this.userStorage.saveUser({ firstname: data.firstname, lastname: data.lastname });
            }
            return true;
        }
        catch (error) {
            if (error instanceof apiError_1.ApiError && error.message == "confirm_email")
                return false;
            throw error;
        }
    }
    /**
    * обновление аватарки
    */
    // async uploadPhotoUser(files: FileList) {//throws
    //     if (!await this.userStorage.isAuth()) throw new ApiError(401, "Пользователь не авторизован")
    //     const response: { success: boolean, photo: string } = await this.fetcher({
    //         route: apiRouteUserUploadPhoto,
    //         postBody: { photo: files },
    //         options: { addToken: true }
    //     })
    //     return this.userStorage.saveUser({ photo: response.photo })
    // }
    /**
    * выход из ЛК
    */
    async logout() {
        if (!await this.userStorage.isAuth())
            throw new apiError_1.ApiError(401, "Пользователь не авторизован");
        await this.userStorage.clearUser();
        await userLogout_1.eventBusUserLogout.broadcast();
    }
    /**
    * выход из ЛК (выход со всех устройств, на сервере будет удален refresh token, accessToken продолжит действовать остаток своего времени. Другие устройства разлогинет в течении 5 минут)
    */
    async logoutAllDevice() {
        if (!await this.userStorage.isAuth())
            throw new apiError_1.ApiError(401, "Пользователь не авторизован");
        await this.fetcher({
            route: apiRoute_1.apiRouteUserLogout,
            postBody: { logout: 1 },
            options: { addToken: true }
        });
        await this.userStorage.clearUser();
        await userLogout_1.eventBusUserLogout.broadcast();
    }
    /**
     * удаление аккаунта пользователя, сделавшего запрос и всех связанных с ним сущностей (уведомлений, выплат, чеков, статистики и т.д.)
     */
    async delete() {
        if (!await this.userStorage.isAuth())
            throw new apiError_1.ApiError(401, "Пользователь не авторизован");
        await this.fetcher({
            route: apiRoute_1.apiRouteUserDelete,
            postBody: { confirm: "1" },
            options: { addToken: true }
        });
        await this.userStorage.clearUser();
        await userLogout_1.eventBusUserLogout.broadcast();
    }
    /**
    * возвращает реф. код пользователя, который другие пользователя вводят при регистрации
    */
    async getMyReferer() {
        return (await this.getFull())?.my_ref_code;
    }
}
exports.ApiUser = ApiUser;
