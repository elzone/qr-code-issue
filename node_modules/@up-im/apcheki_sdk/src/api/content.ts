
import { apiRouteBannerGetRand, apiRouteCatalogInShopByInn, apiRouteCatalogInUserShop, apiRouteCatalogItem, apiRouteCatalogList, apiRouteEnv, apiRouteItemById, apiRouteList, apiRouteNode, apiRouteNodeTree } from "../http/apiRoute";
import { iArticle } from "../interfaces/iArticle";
import { iBank } from "../interfaces/iBank";
import { iBanner } from "../interfaces/iBanner";
import { BannerType, BannerTypeKeys } from "../interfaces/BannerType";
import { iBrand } from "../interfaces/iBrand";
import { iCatalog } from "../interfaces/iCatalog";
import { iCatalogPreview } from "../interfaces/iCatalogPreview";
import { iCity } from "../interfaces/iCity";
import { iContentItem } from "../interfaces/iContentItem";
import { iFilter } from "../interfaces/iFilter";
import { iInstruction } from "../interfaces/iInstruction";
import { iNode } from "../interfaces/iNode";
import { iNodeTree } from "../interfaces/iNodeTree";
import { iPagingItems } from "../interfaces/iPagingItems";
import { iSearchParams } from "../interfaces/iSearchParams";
import { iText } from "../interfaces/iText";
import { ApiAbstract } from "./abstract";
import { iShop } from "../interfaces/iShop";
import { iSymptoms } from "../interfaces/iSymptoms";
import { iStories } from "../interfaces/iStories";
import { iEnv } from "../interfaces/iEnv";
import { iIntro } from "../interfaces/iIntro";

export class ApiContent extends ApiAbstract {
    /**
     * получение настроек, включая размер реферальных вознаграждений
     */
    async getEnv() {
        return this.fetcher<iEnv>({ route: apiRouteEnv })
    }
    /**
     * получение дерева категорий. не обязательный параметр 
     * @param {string} parent id категории от которой строится вложенность
     */
    async getNodeTree(parent?: number) {
        return this.fetcher<iNodeTree[]>({ route: apiRouteNodeTree(parent) })
    }
    /**
     * получение списка категорий по фильтрам
     */
    // private async getNodeList<T>(params: iGetNodeListProps<T>) {
    //     return this.fetcher<iNode<T>[]>({
    //         route: apiRouteNodeList(params)
    //     })
    // }
    /**
     * получение раздела
     */
    private async getNodeByCode<T>(nodeCode: string) {
        return this.fetcher<iNode<T>>({
            route: apiRouteNode(nodeCode)
        })
    }
    /**
     * получение списка категорий по фильтрам
     */
    // async getNodeListCatalog(params: iGetNodeListProps<iCatalogNode>) {
    //     return this.getNodeList(params)
    // }
    /**
    * получение списка статей
    */
    async getArticleList<Keys extends keyof iArticle>({
        select,
        page = 1,//отсчет страниц с первой, чтобы не было путаницы
        filters,
        sorters,
        perPage = 10,
    }: iSearchParams<iArticle, Keys>) {
        return this.fetcher<iPagingItems<Pick<iArticle, Keys> & { url?: string }>>({
            route: apiRouteList({
                nodeCode: "articles",
                page,
                select,
                filters,
                sorters,
                perPage,
            })
        })
    }
    /**
    * получение одной статьи
    */
    async getArticleOne({ id }: { id: number }) {
        return this.fetcher<iContentItem<iArticle>>({
            route: apiRouteItemById("articles", id)
        })
    }
    /**
    * получение списка акций
    * @param {number} params.nodeId - id раздела, если не передан будут выбраны товары всех разделов
    * @param {boolean} params.subNodes - включить или нет товары подкатегорий
    * @param {boolean} params.bookmarks - показать только избранные товары
    */
    async getCatalogList({
        nodeId,
        page = 1,//отсчет страниц с первой, чтобы не было путаницы
        filters,
        // sorters,
        perPage = 10,
        subNodes,
        bookmarks,
    }: {
        nodeId?: number | undefined
        page?: number
        filters?: iFilter<iCatalog & { query?: string, shop?: number }>,
        // sorters?: iSorter<iCatalog>
        perPage?: number
        subNodes?: boolean
        bookmarks?: boolean
    }) {
        const data = await this.fetcher<iPagingItems<iCatalogPreview>>({
            route: apiRouteCatalogList({
                nodeId: nodeId ?? 0,
                page,
                filters,
                //sorters,
                perPage,
                subNodes,
                bookmarks,
            }),
            options: {//для закладок
                addToken: true
            }
        })
        return data
    }
    /**
   * получение одного товара (акции)
   *  @param {string} id - id акции
   */
    async getCatalogOne({ id }: { id: number }) {
        const data = await this.fetcher<iContentItem<iCatalog>>({ route: apiRouteCatalogItem(id) })
        return data
    }
    /**
     * проверка действует ли акция в аптеке пользователя
     * @param {string} id - id акции
     */
    async skuInUserShop({ id }: { id: number }): Promise<boolean> {
        const data = await this.fetcher<{ contains: boolean }>({
            route: apiRouteCatalogInUserShop(id),
            options: { addToken: true }
        })
        return data.contains
    }
    /**
     * проверка по ИНН аптеки участвует или нет акция в аптеке
     * @param {string} params.id - id акции
     * @param {string} params.inn - ИНН аптеки
     */
    async inShopByInn({ id, inn }: { id: number, inn: number }): Promise<boolean> {
        const data = await this.fetcher<{ contains: boolean }>({
            route: apiRouteCatalogInShopByInn(id, inn),
        })
        return data.contains
    }
    /**
  * симптомы
  * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
  * @param {string} props.searchTitle - поисковая строка по началу названия банка
  */
    async getSymptoms({ page, searchTitle }: { page: number, searchTitle?: string }) {
        const filters: iFilter<iSymptoms> = {}
        if (searchTitle?.length) filters.title = [searchTitle + "%"]
        return await this.fetcher<iPagingItems<iSymptoms>>({
            route: apiRouteList({
                nodeCode: "symptoms",
                select: ["id", "title"],
                sorters: ["sorter asc"],
                perPage: 30,
                filters,
                page
            })
        })
    }
    /**
     * получение списка производителей
     */
    async getBrandList<Keys extends keyof iBrand>({
        select,
        page = 1,//отсчет страниц с первой, чтобы не было путаницы
        filters,
        sorters,
        perPage = 10,
    }: iSearchParams<iBrand, Keys>) {
        const data = await this.fetcher<iPagingItems<Pick<iBrand, Keys> & { url?: string }>>({
            route: apiRouteList({
                nodeCode: "brand",
                page,
                select,
                filters,
                sorters,
                perPage,
            })
        })
        return data
    }
    /**
    * политика конфиденциальности
    */
    async getPolicy() {
        return this.getNodeByCode<iText>("policy")
    }
    /**
   * оферта
   */
    async getTerms() {
        return this.getNodeByCode<iText>("terms")
    }
    /**
   * Правила программы лояльности
   */
    async getLoyalty() {
        return this.getNodeByCode<iText>("loyalty")
    }
    /**
    * как получить деньги
    */
    async getInstruction() {
        return await this.fetcher<iPagingItems<iInstruction>>({
            route: apiRouteList({
                nodeCode: "instruction",
                select: ["id", "title", "text", "image"],
                sorters: ["sorter asc"],
                perPage: 100,
            })
        })

    }
    /**
   * банки для выбора при запросе на вывод средств
   * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
   * @param {string} props.searchTitle - поисковая строка по началу названия банка
   */
    async getBanks({ page, searchTitle }: { page: number, searchTitle?: string }) {
        const filters: iFilter<iBank> = {}
        if (searchTitle?.length) filters.title = [searchTitle + "%"]
        return await this.fetcher<iPagingItems<iInstruction>>({
            route: apiRouteList({
                nodeCode: "bank",
                select: ["id", "title"],
                sorters: ["sorter asc", "title asc"],
                perPage: 10,
                filters,
                page
            })
        })
    }
    /**
   * поиск города
   * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
   * @param {string} props.searchTitle - поисковая строка по началу названия банка
   */
    async getCityList({ page, searchTitle }: { page: number, searchTitle?: string }) {
        const filters: iFilter<iCity> = {}
        if (searchTitle?.length) filters.title = [searchTitle + "%"]
        return await this.fetcher<iPagingItems<iCity>>({
            route: apiRouteList({
                nodeCode: "city",
                select: ["id", "title"],
                sorters: ["sorter asc"],
                perPage: 20,
                filters,
                page
            })
        })
    }
    /**
    * получение одного города
    */
    async getCityOne({ id }: { id: number }) {
        return this.fetcher<iContentItem<iArticle>>({
            route: apiRouteItemById("city", id)
        })
    }
    /**
     * поиск аптеки
     * @param {number} props.page - страница. Отсчет страниц с первой, чтобы не было путаницы
     * @param {string} props.searchTitle - поисковая строка по началу названия аптеки
     */
    async getShopList({ page, searchTitle }: { page: number, searchTitle?: string }) {
        const filters: iFilter<iShop> = {}
        if (searchTitle?.length) filters.title = [searchTitle + "%"]
        return await this.fetcher<iPagingItems<iShop>>({
            route: apiRouteList({
                nodeCode: "shop",
                select: ["id", "title", "inn", "address"],
                sorters: ["sorter asc"],
                perPage: 20,
                filters,
                page
            })
        })
    }
    /**
    * получение одной аптеки
    */
    async getShopOne({ id }: { id: number }) {
        return this.fetcher<iContentItem<iShop>>({
            route: apiRouteItemById("shop", id)
        })
    }
    /**
     * баннер
     * @param {number} props.type - тип баннера
     */
    async getBannerRand({ type }: { type: typeof BannerType[BannerTypeKeys] }) {
        return await this.fetcher<{ item: iBanner | undefined }>({
            route: apiRouteBannerGetRand(type),
            options: { addToken: true }
        })
    }
    /**
    * получение списка сторисов
    */
    async getStoriesList<Keys extends keyof iStories>({
        select,
        page = 1,//отсчет страниц с первой, чтобы не было путаницы
        perPage = 10,
    }: iSearchParams<iStories, Keys>): Promise<iPagingItems<Pick<iStories, Keys>>> {
        const data = await this.fetcher<iPagingItems<Pick<iStories, Keys> & { sku: { id: number, title: string } | null }>>({
            route: apiRouteList({
                nodeCode: "stories",
                page,
                select,
                perPage,
            }),
            options: { addToken: true }
        })
        return {
            ...data,
            items: data.items.map(it => ({
                ...it,
                sku: it?.sku
                    ? { id: it.sku.id, title: it.sku.title }
                    : null
            }))
        }
    }
    /**
    * получение одного сториса
    */
    async getStoriesOne({ id }: { id: number }): Promise<iContentItem<iStories>> {
        const data = await this.fetcher<iContentItem<iStories>>({
            route: apiRouteItemById("stories", id)
        })
        return {
            ...data,
            item: {
                ...data.item,
                sku: data.item?.sku
                    ? { id: data.item.sku.id, title: data.item.sku.title }
                    : null
            }
        }
    }
    /**
   * получение списка интро (приветственная инструкция)
   */
    async getIntro() {
        return this.fetcher<iPagingItems<iIntro>>({
            route: apiRouteList({
                nodeCode: "intro",
                select: ["id", "title", "image"],
                sorters: ["sorter asc"],
                perPage: 50,
            })
        })
    }
}