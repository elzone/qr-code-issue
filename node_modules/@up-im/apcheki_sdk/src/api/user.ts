
import { ApiError } from "../http/apiError";
import { apiRouteUserDelete, apiRouteUserEdit, apiRouteUserGetMe, apiRouteUserLoginWithCode, apiRouteUserLogout, apiRouteUserSetRef, apiRouteUserSetShopByInn } from "../http/apiRoute";
import { iUserEditProps } from "../interfaces/iUserEditProps";
import { iUser } from "../interfaces/iUser";
import { iUserTokens } from "../interfaces/iUserTokens";
import { ApiAbstract } from "./abstract";
import { eventBusUserLogin } from "../eventBus/userLogin";
import { eventBusUserLogout } from "../eventBus/userLogout";

export class ApiUser extends ApiAbstract {
    /**
     * получает пользователя из расшифрованного JWT токена без запроса на backend
     */
    get() {
        return this.userStorage.getUser()
    }
    /**
     * получает полную информацию о пользователе с сервера
     */
    async getFull() {
        if (!await this.userStorage.isAuth()) throw new ApiError(401, "Пользователь не авторизован")
        return this.fetcher<iUser>({ route: apiRouteUserGetMe, options: { addToken: true } })
    }
    /**
    * 1ый этап регистрации или авторизации
    */
    async loginOrRegisterByPhone({ phone }: { phone: string }) {
        try {
            await this.fetcher({ route: apiRouteUserLoginWithCode, postBody: { login: phone } })
        } catch (error) {
            if (error instanceof ApiError && error.message == "confirm_phone") return
            throw error
        }
    }
    /**
     * 2ой этап регистрации или авторизации - ввод кода подтверждения
     */
    async loginOrRegisterByPhoneConfirm({ phone, code }: { phone: string, code: string }) {
        const data = await this.fetcher<iUserTokens>({
            route: apiRouteUserLoginWithCode,
            postBody: { login: phone, phone_code: code }
        })
        const user = await this.userStorage.setUser(data.accessToken, data.refreshToken)
        if (user) eventBusUserLogin.broadcast(user)
        return user
    }
    /**
    * Ввод реферального кода другого пользователя
    * @param {string} props.ref - реферальный код
    */
    async setRef({ ref }: { ref: string }) {
        await this.fetcher({
            route: apiRouteUserSetRef,
            postBody: { ref },
            options: { addToken: true }
        })
    }
    /**
    * Установка любимой аптеки по ее ИНН
    * @param {string} props.inn - ИНН аптеки
    */
    async setShopByInn({ inn }: { inn: number }) {
        await this.fetcher({
            route: apiRouteUserSetShopByInn,
            postBody: { inn },
            options: { addToken: true }
        })
    }
    /**
    * редактирование пользователя
    * если метод вернул false - то необходимо ввести код из email и передать его в data.email_code
    * @param {string} props.email - опционально, для смены email. Если емейл не меняется то не передаем этот параметр или передаем пустую строку
    * @param {number} props.city - id города
    * @param {string} props.email_code - код отправленный на email. Первый раз метод вызывается без него, если метод вернул false необходимо вызвать повторно передав код из email
    */
    async editUser(data: iUserEditProps) {
        if (!await this.userStorage.isAuth()) throw new ApiError(401, "Пользователь не авторизован")
        try {
            await this.fetcher({
                route: apiRouteUserEdit,
                postBody: data,
                options: { addToken: true }
            })
            if (data.firstname?.length && data.lastname?.length) {
                await this.userStorage.saveUser({ firstname: data.firstname, lastname: data.lastname })
            }
            return true
        } catch (error) {
            if (error instanceof ApiError && error.message == "confirm_email") return false
            throw error
        }

    }
    /**
    * обновление аватарки
    */
    // async uploadPhotoUser(files: FileList) {//throws
    //     if (!await this.userStorage.isAuth()) throw new ApiError(401, "Пользователь не авторизован")
    //     const response: { success: boolean, photo: string } = await this.fetcher({
    //         route: apiRouteUserUploadPhoto,
    //         postBody: { photo: files },
    //         options: { addToken: true }
    //     })
    //     return this.userStorage.saveUser({ photo: response.photo })
    // }
    /**
    * выход из ЛК
    */
    async logout() {
        if (!await this.userStorage.isAuth()) throw new ApiError(401, "Пользователь не авторизован")
        await this.userStorage.clearUser()
        await eventBusUserLogout.broadcast()
    }
    /**
    * выход из ЛК (выход со всех устройств, на сервере будет удален refresh token, accessToken продолжит действовать остаток своего времени. Другие устройства разлогинет в течении 5 минут)
    */
    async logoutAllDevice() {
        if (!await this.userStorage.isAuth()) throw new ApiError(401, "Пользователь не авторизован")
        await this.fetcher({
            route: apiRouteUserLogout,
            postBody: { logout: 1 },
            options: { addToken: true }
        })
        await this.userStorage.clearUser()
        await eventBusUserLogout.broadcast()
    }
    /**
   * подписка на событие logout
   */
    onLogout = eventBusUserLogout.subscribe
    /**
     * удаление аккаунта пользователя, сделавшего запрос и всех связанных с ним сущностей (уведомлений, выплат, чеков, статистики и т.д.)
     */
    async delete() {
        if (!await this.userStorage.isAuth()) throw new ApiError(401, "Пользователь не авторизован")
        await this.fetcher({
            route: apiRouteUserDelete,
            postBody: { confirm: "1" },
            options: { addToken: true }
        })
        await this.userStorage.clearUser()
        await eventBusUserLogout.broadcast()
    }

    /**
    * возвращает реф. код пользователя, который другие пользователя вводят при регистрации
    */
    async getMyReferer() {
        return (await this.getFull())?.my_ref_code
    }
}